<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>M3U Category Filter</title>

<style>
  :root{
    --bg:#0b0f14; --panel:#121923; --muted:#9fb0c3; --text:#e8f0fb;
    --acc:#5ac8fa; --ok:#30d158; --danger:#ff453a; --border:#1f2a38;
    --chip:#172231; --chip-off:#111a26; --chip-border:#243548;
    --switch-off:#0f1a28; --switch-on:#57c6fb; --knob:#0a1018;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    background:linear-gradient(180deg,#0a1018,#0b0f14 40%);
    color:var(--text);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Inter,sans-serif;
  }
  header{
    position:sticky;top:0;z-index:10;
    background:rgba(11,15,20,.8);
    backdrop-filter:saturate(140%) blur(10px);
    border-bottom:1px solid var(--border)
  }
  .wrap{max-width:1100px;margin:0 auto;padding:20px}
  h1{margin:0;font-weight:800;letter-spacing:.3px;font-size:clamp(22px,3.6vw,28px)}
  main{padding:24px 0}

  .card{background:var(--panel);border:1px solid var(--border);border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
  .card .body{padding:16px}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  input[type="text"]{
    flex:1;min-width:260px;background:#0e1621;border:1px solid #1e2a39;
    color:var(--text);padding:12px;border-radius:10px;outline:none
  }
  .btn{appearance:none;border:1px solid transparent;background:var(--acc);color:#05121d;padding:10px 14px;border-radius:12px;font-weight:700;cursor:pointer}
  .btn.ok{background:var(--ok);color:#00140b}
  .btn.danger{background:var(--danger);color:#140001}
  .btn.ghost{background:transparent;color:var(--text);border-color:#294059}
  .hint{font-size:13px;color:var(--muted)}

  /* Tabs ‚Äî 3 responsive columns */
  .tabs{
    display:grid;
    grid-template-columns:repeat(3, minmax(0,1fr));
    gap:10px;
    align-items:stretch;
    margin:8px 0 0;
  }
  .tab{
    min-width:0;
    text-align:center;
    padding:10px 12px;
    border-radius:999px;
    border:1px solid #223146;
    background:#0f1622; color:#cfe0f7;
    cursor:pointer; user-select:none;
    font-size:clamp(13px,3.3vw,16px);
    transition:transform .12s ease, box-shadow .12s ease, background .2s ease;
  }
  .tab:hover{transform:translateY(-1px); box-shadow:0 6px 16px rgba(0,0,0,.25)}
  .tab.active{background:linear-gradient(135deg,#5ac8fa,#8ec5ff); color:#06131f}
  .tab b{letter-spacing:.2px}
  .tab small{opacity:.85;margin-left:6px}

  /* Toolbar center */
  .toolbar{display:flex;flex-wrap:wrap;gap:10px;margin:12px 0}
  .toolbar.center{justify-content:center;}

  /* Category list area */
  .chips{
    display:flex; flex-direction:column; gap:10px; margin:12px 0 0;
    max-height:50vh; overflow:auto; padding-right:6px; scroll-behavior:smooth;
  }
  .chips::-webkit-scrollbar{width:8px}
  .chips::-webkit-scrollbar-track{background:#0d1520;border-radius:8px}
  .chips::-webkit-scrollbar-thumb{background:#1f3248;border-radius:8px}
  .chips::-webkit-scrollbar-thumb:hover{background:#28425e}

  .chip{
    display:flex; align-items:center; gap:12px;
    border:1px solid var(--chip-border); background:var(--chip);
    padding:10px 12px; border-radius:999px;
    transition:filter .15s ease, background .15s ease, border-color .15s ease;
  }
  .chip.off{background:var(--chip-off); filter:saturate(.6) brightness(.9); border-color:#1d2a3a}
  .chip .name{flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis}
  .chip .count{font-size:12px;color:#9fb0c3}

  /* ON/OFF Switch */
  .switch{
    position:relative; width:46px; height:26px; border-radius:999px;
    background:var(--switch-off); border:1px solid #244057; flex:none;
    transition:background .15s ease, border-color .15s ease;
  }
  .switch::after{
    content:""; position:absolute; top:50%; transform:translateY(-50%);
    left:3px; width:20px; height:20px; border-radius:50%;
    background:var(--knob); box-shadow:0 1px 0 rgba(255,255,255,.08), 0 2px 6px rgba(0,0,0,.5);
    transition:left .18s ease;
  }
  .switch.on{background:var(--switch-on); border-color:#2a84a8}
  .switch.on::after{left:23px}

  /* Stats and table */
  .statbar{display:grid;grid-template-columns:repeat(3,1fr);gap:10px}
  .stat{background:#0e1723;border:1px solid #233246;border-radius:12px;padding:10px}
  .stat b{display:block;font-size:18px}
  .table{border:1px solid #223146;border-radius:12px;overflow:auto}
  table{width:100%;border-collapse:collapse;font-size:14px}
  th,td{padding:10px;border-bottom:1px solid #1d2b3e}
  th{position:sticky;top:0;background:#0d1723;text-align:left}

  @media (max-width:420px){
    .wrap{padding:16px;}
    .toolbar.center{gap:12px;}
  }
  @media (max-width:360px){
    .tab{padding:9px 10px;}
  }

  /* ===== Gradient animated title ===== */
  .title-gradient{
    background:linear-gradient(90deg,#5ac8fa 0%,#8b5cf6 45%,#f472b6 100%);
    background-size:200% 100%;
    -webkit-background-clip:text;
    background-clip:text;
    color:transparent;
    font-weight:900;
    letter-spacing:.3px;
    text-align:center;
    text-shadow:0 0 0 transparent,0 0 24px rgba(138,180,248,.15);
    animation:gradientSlide 8s ease-in-out infinite, wipeFade 5s ease-in-out infinite;
  }
  @keyframes gradientSlide{
    0%{background-position:0% 50%;}
    50%{background-position:100% 50%;}
    100%{background-position:0% 50%;}
  }
  .title-gradient{
    -webkit-mask:linear-gradient(90deg,rgba(0,0,0,1) 0%,rgba(0,0,0,1) 20%,rgba(0,0,0,0) 35%,rgba(0,0,0,0) 65%,rgba(0,0,0,1) 80%,rgba(0,0,0,1) 100%) left/200% 100% no-repeat;
    mask:linear-gradient(90deg,rgba(0,0,0,1) 0%,rgba(0,0,0,1) 20%,rgba(0,0,0,0) 35%,rgba(0,0,0,0) 65%,rgba(0,0,0,1) 80%,rgba(0,0,0,1) 100%) left/200% 100% no-repeat;
  }
  @keyframes wipeFade{
    0%{-webkit-mask-position:left;mask-position:left;}
    50%{-webkit-mask-position:right;mask-position:right;}
    100%{-webkit-mask-position:left;mask-position:left;}
  }
  header h1.title-gradient{font-size:clamp(28px,6.2vw,54px);}

  /* Animated export button */
  .btn.ok {
    background: linear-gradient(90deg, #30d158, #5ac8fa, #f472b6);
    background-size: 300% 100%;
    color: #00140b;
    border: none;
    font-weight: 700;
    animation: btnGradient 6s ease-in-out infinite;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
  }
  .btn.ok:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
  }
  @keyframes btnGradient {
    0%{background-position:0% 50%;}
    50%{background-position:100% 50%;}
    100%{background-position:0% 50%;}
  }

  /* === Redesigned stats section === */
  .statwrap{display:flex;gap:16px;align-items:stretch}
  .stat{
    background:#0e1723;
    border:1px solid #233246;
    border-radius:14px;
    padding:12px;
    box-shadow:0 6px 20px rgba(0,0,0,.25), inset 0 1px 0 rgba(255,255,255,.03);
    flex:1;
  }
  .stat.small{padding:8px 10px}
  .stat .label{font-size:13px;opacity:.9;color:#9fb0c3;}
  .stat .value{
    display:block;font-size:30px;font-weight:800;margin-top:4px;letter-spacing:.3px;
    color:#e8f0fb;text-shadow:0 0 12px rgba(90,200,250,.2);
  }

  .vbar{
    width:14px;min-width:14px;border-radius:12px;background:#0e1723;border:1px solid #233246;
    position:relative;overflow:hidden;box-shadow:inset 0 2px 8px rgba(0,0,0,.35);
  }
  .vbar__fill{
    position:absolute;left:0;right:0;bottom:0;height:0%;
    background:linear-gradient(180deg,#22c55e 0%, #f59e0b 50%, #ef4444 100%);
    transition:height .35s ease;
  }
  .vbar.is-empty .vbar__fill{
    background:linear-gradient(180deg,#64748b 0%, #475569 100%);
  }
  .stat-column .stat.small{text-align:center;}
  .statwrap{display:flex;gap:18px;justify-content:space-between;align-items:stretch;}
</style>
</head>
<body>
<header>
  <div class="wrap" style="display:flex;align-items:center;justify-content:center;gap:14px">
    <h1 class="title-gradient">ùó†ùüØùó® ùóñùóÆùòÅùó≤ùó¥ùóºùóøùòÜ ùóôùó∂ùóπùòÅùó≤ùóø</h1>
  </div>
</header>

<main class="wrap">
  <!-- URL input -->
  <section class="card">
    <div class="body">
      <div class="hint" style="margin:0 0 8px 2px;">Paste your M3U URL</div>

      <div class="row">
        <input id="m3uUrl" type="text"
          placeholder="M3U URL (‚Ä¶/get.php?username=..&password=..&type=m3u_plus)" />
        <button class="btn" id="btnFetch">Load URL</button>
      </div>

      <div id="domainInfo" class="hint" style="margin-top:6px;"></div>
      <div class="hint" id="status" style="margin-top:6px;"></div>
    </div>
  </section>
<!-- Tabs + categories -->
  <section class="card" style="margin-top:16px">
    <div class="body">
      <div class="tabs">
        <div class="tab active" data-type="live">
          <b>TV</b><small id="count-live">0</small>
        </div>
        <div class="tab" data-type="vod">
          <b>VOD</b><small id="count-vod">0</small>
        </div>
        <div class="tab" data-type="series">
          <b>Series</b><small id="count-series">0</small>
        </div>
      </div>

      <div class="toolbar center">
        <button class="btn ghost" id="btnAll">Select all</button>
        <button class="btn ghost" id="btnNone">Deselect all</button>
      </div>

      <div id="chips" class="chips"></div>
    </div>
  </section>

  <!-- Stats + export (Categories left, Totals right) -->
  <section class="card" style="margin-top:16px">
    <div class="body">
      <div class="statwrap" style="align-items:stretch;">
        <!-- Categories LEFT -->
        <div class="stat" style="flex:1;text-align:center;">
          <div class="label">Categories</div>
          <b class="value" id="statCats">0</b>
        </div>

        <!-- RIGHT column: Total (top) / After filter (bottom) -->
        <div class="stat-column" style="display:flex;flex-direction:column;justify-content:space-between;gap:10px;flex:0 0 130px;">
          <div class="stat small">
            <div class="label">Total entries</div>
            <b class="value" id="statTotal">0</b>
          </div>
          <div class="stat small">
            <div class="label">After filter</div>
            <b class="value" id="statAfter">0</b>
          </div>
        </div>

        <!-- Vertical bar at far right -->
        <div class="vbar" id="keepBar" style="margin-left:16px;">
          <div class="vbar__fill" id="keepFill"></div>
        </div>
      </div>

      <div class="toolbar" style="margin-top:14px;">
        <button class="btn ok" id="btnExport">Export M3U (active type)</button>
        <button class="btn" id="btnPreview">Preview 200 lines</button>
        <span class="hint" id="exportHint"></span>
      </div>

      <div class="table" style="margin-top:10px;display:none" id="previewBox">
        <table>
          <thead>
            <tr><th>#</th><th>EXTINF</th><th>URL</th></tr>
          </thead>
          <tbody id="previewT"></tbody>
        </table>
      </div>
    </div>
  </section>
</main>

<script>
(function(){
  "use strict";

  /* Forced proxy (hidden in UI) */
  const PROXY = "https://vegetatv1.vegetatvoficial.workers.dev/?url=";
  const through = (url) => PROXY + encodeURIComponent(url);

  /* State */
  const el = (id)=>document.getElementById(id);
  const status = el("status");
  let activeType = "live";                 // 'live' | 'vod' | 'series'
  const selected = {live:new Set(), vod:new Set(), series:new Set()};
  const cats     = {live:[], vod:[], series:[]};       // [{id,name,count}]
  const streams  = {live:[], vod:[], series:[]};       // items
  let mode = "m3u";                                   // 'm3u' or 'xtream'
  let xtream = null;

  function setStatus(msg){ status.textContent = msg || ""; }
  function extractDomainFromUrl(url){
    try{ return new URL(url.trim()).hostname.replace(/^www\./,''); } catch{ return ""; }
  }
  function setDetectedDomain(domain){
    const info = el('domainInfo');
    const hint = el('exportHint');
    if(domain){ info.textContent = "üåê Detected domain: " + domain; hint.dataset.domain = domain; }
    else { info.textContent = ""; delete hint.dataset.domain; }
  }

  /* Tabs */
  document.querySelectorAll('.tab').forEach(t=>{
    t.addEventListener('click', ()=>{
      document.querySelectorAll('.tab').forEach(x=>x.classList.remove('active'));
      t.classList.add('active');
      activeType = t.dataset.type;
      renderChips();
      refreshStats();
    });
  });

  /* Utils */
  function escapeHtml(s){
  const map = {"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;"};
  return String(s).replace(/[&<>"]/g, c => map[c]);
}
  function groupBy(arr, key){ const m=new Map(); for(const it of arr){ const k=it[key]; m.set(k,(m.get(k)||0)+1); } return m; }
  function titleEscape(s){ return String(s).replace(/"/g,'\\"'); }

  /* M3U parser */
  function parseM3U(text){
    const lines = String(text||"").replace(/\r/g,"").split(/\n/);
    const items = [];
    for(let i=0;i<lines.length;i++){
      const line = (lines[i]||"").trim(); if(!line) continue;
      if(line.startsWith("#EXTINF")){
        const ext = line; let url=""; let j=i+1;
        while(j<lines.length && !(url=(lines[j]||"").trim())) j++;
        let group = "Other"; const m = ext.match(/group-title\s*=\s*"([^"]*)"/i); if(m) group = m[1];
        items.push({ext,url,group}); i=j;
      }
    }
    return items;
  }

  function loadM3U(text){
    mode = "m3u";
    const items = parseM3U(text);
    streams.live = items; streams.vod = []; streams.series = [];
    const map = groupBy(items,"group");
    cats.live = [...map.entries()]
      .sort((a,b)=>a[0].localeCompare(b[0],'en',{sensitivity:'base'}))
      .map(([name,count])=>({id:name,name,count}));
    selected.live = new Set(cats.live.map(c=>c.id));
    cats.vod=[]; cats.series=[]; selected.vod.clear(); selected.series.clear();
    activeType="live"; document.querySelector('[data-type="live"]').click();
    el('count-live').textContent = String(items.length);
    el('count-vod').textContent = "0"; el('count-series').textContent = "0";
    setStatus("OK ‚Äî M3U loaded.");
  }

  /* Xtream */
  function parseXtreamFromGet(url){
  try {
    const u = new URL(url);

    const host = u.hostname;
    const rawPort = u.port;                 // ex: "8080" ou ""
    const port = rawPort ? `:${rawPort}` : "";

    const q = new URLSearchParams(u.search);
    const user = q.get("username");
    const pass = q.get("password");
    if (!user || !pass) return null;

    // ‚úÖ Conserver le protocole exact d'entr√©e ("http:" ou "https:")
    const proto = u.protocol;

    // ‚úÖ Stocker aussi le protocole original pour l'export (m√™me si la page est HTTPS)
    const originalProto = proto;

    // Base API qui respecte le protocole d'origine
    const base = `${proto}//${host}${port}/player_api.php?username=${encodeURIComponent(user)}&password=${encodeURIComponent(pass)}`;

    return {
      base,              // ex: http://host:port/player_api.php?username=...&password=...
      host,              // ex: "vipketseyket.top"
      port: rawPort,     // ex: "8080" (sans le ':')
      u: user,
      p: pass,
      domain: host,      // alias pratique
      proto,             // ex: "http:" ou "https:"
      originalProto      // ‚ö° √† utiliser dans export pour respecter ton lien d‚Äôorigine
    };
  } catch (e) {
    return null;
  }
}
  async function fetchJson(url){ const r = await fetch(through(url), {cache:"no-store"}); if(!r.ok) throw new Error("HTTP "+r.status); return r.json(); }

  async function loadXtream(getUrl){
    mode="xtream"; xtream = parseXtreamFromGet(getUrl); if(!xtream) throw new Error("Invalid Xtream URL (missing username/password).");
    const [liveCats, vodCats, seriesCats] = await Promise.all([
      fetchJson(`${xtream.base}&action=get_live_categories`),
      fetchJson(`${xtream.base}&action=get_vod_categories`),
      fetchJson(`${xtream.base}&action=get_series_categories`)
    ]);
    const [liveStreams, vodStreams, seriesItems] = await Promise.all([
      fetchJson(`${xtream.base}&action=get_live_streams`),
      fetchJson(`${xtream.base}&action=get_vod_streams`),
      fetchJson(`${xtream.base}&action=get_series`)
    ]);

    const liveCounts = groupBy(liveStreams,"category_id");
    cats.live = liveCats.map(c=>({id:c.category_id,name:c.category_name,count:liveCounts.get(c.category_id)||0}))
                        .sort((a,b)=>a.name.localeCompare(b.name,'en',{sensitivity:'base'}));
    streams.live = liveStreams; selected.live = new Set(cats.live.map(c=>c.id)); el('count-live').textContent=String(liveStreams.length);

    const vodCounts = groupBy(vodStreams,"category_id");
    cats.vod = vodCats.map(c=>({id:c.category_id,name:c.category_name,count:vodCounts.get(c.category_id)||0}))
                      .sort((a,b)=>a.name.localeCompare(b.name,'en',{sensitivity:'base'}));
    streams.vod = vodStreams; selected.vod = new Set(cats.vod.map(c=>c.id)); el('count-vod').textContent=String(vodStreams.length);

    const serCounts = groupBy(seriesItems,"category_id");
    cats.series = seriesCats.map(c=>({id:c.category_id,name:c.category_name,count:serCounts.get(c.category_id)||0}))
                            .sort((a,b)=>a.name.localeCompare(b.name,'en',{sensitivity:'base'}));
    streams.series = seriesItems; selected.series = new Set(cats.series.map(c=>c.id)); el('count-series').textContent=String(seriesItems.length);

    activeType="live"; document.querySelector('[data-type="live"]').click();
    setStatus("OK ‚Äî Xtream (TV/VOD/Series categories) loaded.");
  }

  /* Render categories + switches */
  function renderChips(){
    const wrap = el("chips"); wrap.innerHTML = "";
    const list = cats[activeType] || []; el('statCats').textContent = list.length;
    const currentSelected = selected[activeType];

    for(const c of list){
      const chip = document.createElement("label");
      chip.className = "chip";
      if(!currentSelected.has(c.id)) chip.classList.add("off");

      const sw = document.createElement("span");
      sw.className = "switch" + (currentSelected.has(c.id) ? " on" : "");
      const name = document.createElement("span"); name.className="name"; name.textContent = c.name;
      const cnt  = document.createElement("span"); cnt.className="count"; cnt.textContent = c.count;

      const toggle = () => {
        if(currentSelected.has(c.id)){ currentSelected.delete(c.id); sw.classList.remove("on"); chip.classList.add("off"); }
        else { currentSelected.add(c.id); sw.classList.add("on"); chip.classList.remove("off"); }
        refreshStats();
      };
      sw.addEventListener("click", (e)=>{ e.preventDefault(); toggle(); });
      chip.addEventListener("click", (e)=>{ if(e.target===chip || e.target===name || e.target===cnt){ toggle(); } });

      chip.append(sw, name, cnt); wrap.append(chip);
    }
  }

  /* Stats */
  function refreshStats(){
    let total=0, kept=0;

    if(mode==="m3u" && activeType==="live"){
      total = streams.live.length;
      const keep = selected.live; const keepAll = keep.size===0;
      for(const it of streams.live){ if(keepAll || keep.has(it.group)) kept++; }
    }else{
      const arr = streams[activeType] || [];
      const keep = selected[activeType]; const keepAll = keep.size===0;
      total = arr.length;
      for(const s of arr){ if(keepAll || keep.has(s.category_id)) kept++; }
    }

    el("statTotal").textContent = total;
    el("statAfter").textContent = kept;
    updateKeepBar(total, kept);
  }

  function updateKeepBar(total, kept){
    const fill = document.getElementById("keepFill");
    const bar  = document.getElementById("keepBar");
    if(!fill || !bar) return;

    if(total <= 0){
      bar.classList.add("is-empty");
      fill.style.height = "0%";
      fill.title = "0% kept";
      return;
    }
    bar.classList.remove("is-empty");
    const pct = Math.max(0, Math.min(100, Math.round((kept/total)*100)));
    fill.style.height = pct + "%";
    fill.title = pct + "% kept";
  }

  /* Export */
  function filenameBase(){ return (el("exportHint").dataset.domain || "filtered").replace(/[^a-z0-9.-]/gi,"_"); }

  function exportM3U_live_xtream(){
    const baseHost = (xtream.originalProto || xtream.proto) + "//" + xtream.host + (xtream.port ? (":" + xtream.port) : "");
    const keep = selected.live; const keepAll = keep.size===0; const parts=["#EXTM3U"];
    for(const s of streams.live){
      if(keepAll || keep.has(s.category_id)){
        const catName = (cats.live.find(c=>c.id==s.category_id)||{}).name || "TV";
        const title = s.name || s.stream_display_name || ("Live " + s.stream_id);
        const ext = `#EXTINF:-1 tvg-id="" group-title="${titleEscape(catName)}", ${titleEscape(title)}`;
        const url = `${baseHost}/live/${encodeURIComponent(xtream.u)}/${encodeURIComponent(xtream.p)}/${s.stream_id}.m3u8`;
        parts.push(ext,url);
      }
    }
    return parts.join("\n")+"\n";
  }

  function exportM3U_vod_xtream(){
  // Respecte le protocole d‚Äôentr√©e (HTTP reste HTTP)
  const baseHost = xtream.proto + "//" + xtream.host + (xtream.port ? (":" + xtream.port) : "");

  const keep = selected.vod;
  const keepAll = keep.size === 0;
  const parts = ["#EXTM3U"];

  for (const s of streams.vod){
    if (keepAll || keep.has(s.category_id)){
      const catName = (cats.vod.find(c => c.id == s.category_id) || {}).name || "VOD";
      const title = s.name || s.stream_display_name || ("VOD " + s.stream_id);
      const extn = s.container_extension || "mp4";
      const ext  = `#EXTINF:-1 tvg-id="" group-title="${titleEscape(catName)}", ${titleEscape(title)}`;
      const url  = `${baseHost}/movie/${encodeURIComponent(xtream.u)}/${encodeURIComponent(xtream.p)}/${s.stream_id}.${extn}`;
      parts.push(ext, url);
    }
  }
  return parts.join("\n") + "\n";
}

  function exportM3U_m3u_simple(){
    const keep = selected.live; const keepAll = keep.size===0; const parts=["#EXTM3U"];
    for(const it of streams.live){ if(keepAll || keep.has(it.group)){ parts.push(it.ext,it.url); } }
    return parts.join("\n")+"\n";
  }

  function doExport(){
    let data="";
    if(mode==="xtream"){
      if(activeType==="live") data = exportM3U_live_xtream();
      else if(activeType==="vod") data = exportM3U_vod_xtream();
      else { alert("Series export disabled (too large to handle in browser)."); return; }
    }else{
      if(activeType!=="live"){ alert("This M3U contains only channels (TV tab)."); return; }
      data = exportM3U_m3u_simple();
    }
    const blob = new Blob([data], {type:"application/octet-stream"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = `${filenameBase()}_${activeType}_filtered.m3u`;
    a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),12000);
    el("exportHint").textContent = "Generated file: " + a.download;
  }

  /* Preview 200 lines */
  function showPreview(){
  let rows = [];
  let idx = 0;
  const add = (ext, url) =>
    rows.push(
      `<tr><td>${++idx}</td><td>${escapeHtml(ext)}</td><td>${escapeHtml(url)}</td></tr>`
    );

  if (mode === "xtream") {
    // ‚úÖ Respecte le protocole d‚Äôorigine (http ou https)
    const baseHost = xtream.proto + "//" + xtream.host + (xtream.port ? (":" + xtream.port) : "");

    if (activeType === "live") {
      const keep = selected.live;
      const keepAll = keep.size === 0;

      for (const s of streams.live) {
        if (keepAll || keep.has(s.category_id)) {
          const cat = (cats.live.find(c => c.id == s.category_id) || {}).name || "TV";
          const t = s.name || s.stream_display_name || ("Live " + s.stream_id);
          add(
            `#EXTINF:-1 tvg-id="" group-title="${titleEscape(cat)}", ${titleEscape(t)}`,
            `${baseHost}/live/${encodeURIComponent(xtream.u)}/${encodeURIComponent(xtream.p)}/${s.stream_id}.m3u8`
          );
          if (idx >= 200) break;
        }
      }

    } else if (activeType === "vod") {
      const keep = selected.vod;
      const keepAll = keep.size === 0;

      for (const s of streams.vod) {
        if (keepAll || keep.has(s.category_id)) {
          const cat = (cats.vod.find(c => c.id == s.category_id) || {}).name || "VOD";
          const t = s.name || s.stream_display_name || ("VOD " + s.stream_id);
          const extn = s.container_extension || "mp4";
          add(
            `#EXTINF:-1 tvg-id="" group-title="${titleEscape(cat)}", ${titleEscape(t)}`,
            `${baseHost}/movie/${encodeURIComponent(xtream.u)}/${encodeURIComponent(xtream.p)}/${s.stream_id}.${extn}`
          );
          if (idx >= 200) break;
        }
      }

    } else {
      rows = ['<tr><td colspan="3">Series preview disabled (too many episodes).</td></tr>'];
    }

  } else {
    const keep = selected.live;
    const keepAll = keep.size === 0;
    for (const it of streams.live) {
      if (keepAll || keep.has(it.group)) {
        add(it.ext, it.url);
        if (idx >= 200) break;
      }
    }
  }

  document.getElementById("previewT").innerHTML = rows.join("");
  document.getElementById("previewBox").style.display = "block";
}
  /* Load URL */
  async function loadFromUrl(){
    const url = el("m3uUrl").value.trim(); if(!url){ setStatus("Enter a URL."); return; }
    setDetectedDomain(extractDomainFromUrl(url)); setStatus("Loading‚Ä¶");
    try{
      if(/\/get\.php/i.test(url)){ await loadXtream(url); }
      else{
        const res = await fetch(through(url), {cache:"no-store"}); if(!res.ok) throw new Error("HTTP "+res.status);
        const text = await res.text(); loadM3U(text);
      }
    }catch(e){ console.error(e); setStatus("Failed: "+e.message); alert("Load failed: "+e.message); }
  }

  /* UI bindings */
  el("btnFetch").onclick = loadFromUrl;
  el("btnExport").onclick = doExport;
  el("btnPreview").onclick = showPreview;
  el("btnAll").onclick  = ()=>{ const s=selected[activeType]; s.clear(); for(const c of cats[activeType]) s.add(c.id); renderChips(); refreshStats(); };
  el("btnNone").onclick = ()=>{ selected[activeType].clear(); renderChips(); refreshStats(); };
})();

</script>
<!-- Footer signature -->
  <footer style="
    text-align:center;
    padding:20px 0 26px;
    font-size:13px;
    color:#7a8ca5;
    opacity:0.8;
    letter-spacing:0.5px;
  ">
    <span style="font-weight:600;"<span style="color:#5ac8fa;">by IGOR</span>
  </footer>
</body>
</html>